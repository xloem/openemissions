Using gnuradio blocks lets one move towards working with open freedom communities.
Gnuradio blocks are all documented at the gnuradio wiki.

Everyone's goal of course is a general-purpose workbench, but you have to start somewhere.

Pad Crop Block:
    Made before learning of the time raster sink's column parameter, for organising theoriesed packets together.
    Likely useful later for isolating subportions of signals or their ffts.
    Make these:
        A signal source containing clocked packets, such as the noiscillate generator, a radio, or a square wave summed with a noise source
        Gui Widgets->QT->QT GUI Range
            Change properties:
                id: packet_rate
                label: Packet Frequency
                Default Value: guess the packet frequency (this can also be calculated from a double fft or double autocorrelation as the first peak)
                Start: minimum guess
                Stop: maximum guess
                Step: [guessed frequency] / samp_rate
    Connect these:
        Type Converters->Complex to Mag^2 (or anything else that outputs float or byte)
        Instrumentation->QT->QT GUI Time Raster Sink
            Change properties:
                Num. Cols: int(samp_rate / packet_rate + 0.5)

    Now 
                        configure this to guess the period of the waveform
        openemissions->Tagged Stream Pad/Crop
        Video->Video SDL Sink
                        configure the pad/crop block to output the periods aligned with the video width
                        now any similarities between them are visually clear as vertical bars
            TODO: time raster is working better for this than video sdl; it updates before reaching the bottom scanline, etc

PiGPIO Sink Block:
    This is useful for driving hardware based on a time-synchronised signal.
    In Karl's noiscillate experiment, he has a noise generator connected via a relay to a raspberry pi pin.
    
    Connect these:
        Waveform Generators->Signal Source
                        configure to a square wave with a low frequency
        openemissions->PiGPIO Sink
                        oscillate power to a device using a relay
                        now the same flowgraph can be used mathematically to compare the signal environment with and without the device powered

- [X] reduce wave buffer percentage so it doesn't underrun
- [ ] record direct signal to file, then switch to using antenna
- [ ] start with a downsampled 40 hertz signal so we can do the juicy new stuff first before the signal drift recorrelation
- [ ] accumulate well-known distribution of samples for each packet offset [might theoretically feed back into this once signal power is known, to recalibrate live]
            store it in a matrix variable, a vector of distributions
            {foreground model: gives probability distribution given time-point}
- [ ] accumulate distribution of samples of background noise from waveform of known zero times
            if there are things near the tuning frequency, there will be periodic components here, and using a frequency transform could give better prediction
                if the data is treated as short real-valued FFTs, or downsampled below the receiver bandwidth, then changes from real signals could really decrease
                ffts could also be phase-aligned, most simplistically by rotating their data, or the data could be treated as one big frequency-domain chunk
            {background model: gives probability distribution given time-point}
- [ ] loop to identify power distribution:
        for each packet offset:
            for each item of background model:
                use foreground model to calculate what signal power this combination of possibilities implies
                accumulate weighted product into power distribution.  note: modelled signal strength as data density among integral of signal strength
- [ ] draw live power distribution
- [ ] feed back to recalibrate signal distribution?
        once power is well known, the background noise distrubiton can be re-iterated from the samples to reform a signal distribution
