Using gnuradio blocks lets one move towards working with open freedom communities.
Gnuradio blocks are all documented at the gnuradio wiki.

Everyone's goal of course is a general-purpose workbench, but you have to start somewhere.

Pad Crop Block:
    This is useful for organising wave periods together while adjusting theorised periods.
            note: there may be helpful blocks under Resamplers to shrink the waves for display if the sample rate is high
                  rescaling could also be added to pad/crop, or sdl video, but gnuradio's way seems to be to use a hier block to move towards user design
    Connect these:
        Stream Tag Tools->Stream to Tagged Stream
                        configure this to guess the period of the waveform
        openemissions->Tagged Stream Pad/Crop
        Video->Video SDL Sink
                        configure the pad/crop block to output the periods aligned with the video width
                        now any similarities between them are visually clear as vertical bars
            TODO: time raster is working better for this than video sdl; it updates before reaching the bottom scanline, etc

PiGPIO Sink Block:
    This is useful for driving hardware based on a time-synchronised signal.
    In Karl's noiscillate experiment, he has a noise generator connected via a relay to a raspberry pi pin.
    
    Connect these:
        Waveform Generators->Signal Source
                        configure to a square wave with a low frequency
        openemissions->PiGPIO Sink
                        oscillate power to a device using a relay
                        now the same flowgraph can be used mathematically to compare the signal environment with and without the device powered

- [ ] reduce wave buffer percentage so it doesn't underrun
- [ ] record direct signal to file, then switch to using antenna
- [ ] start with a downsampled 40 hertz signal so we can do the juicy new stuff first before the signal drift recorrelation
- [ ] accumulate well-known distribution of samples for each packet offset [might theoretically feed back into this once signal power is known, to recalibrate live]
            store it in a matrix variable, a vector of distributions
            {foreground model: gives probability distribution given time-point}
- [ ] accumulate distribution of samples of background noise from waveform of known zero times
            if there are things near the tuning frequency, there will be periodic components here, and using a frequency transform could give better prediction
                if the data is treated as short real-valued FFTs, or downsampled below the receiver bandwidth, then changes from real signals could really decrease
                ffts could also be phase-aligned, most simplistically by rotating their data, or the data could be treated as one big frequency-domain chunk
            {background model: gives probability distribution given time-point}
- [ ] loop to identify power distribution:
        for each packet offset:
            for each item of background model:
                use foreground model to calculate what signal power this combination of possibilities implies
                accumulate weighted product into power distribution.  note: modelled signal strength as data density among integral of signal strength
- [ ] draw live power distribution
- [ ] feed back to recalibrate signal distribution?
        once power is well known, the background noise distrubiton can be re-iterated from the samples to reform a signal distribution
